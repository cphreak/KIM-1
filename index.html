<!DOCTYPE html>
<html>
<head>
  <link href="css/style.css" rel="stylesheet" type="text/css" />
  <title>Online KIM-1 emulator</title>
  <script src="js/7-segment-display/p5.min.js"></script>
  <script src="js/7-segment-display/p5.dom.min.js"></script>
  <link rel="stylesheet" type="text/css" href="">
  <meta charset="utf-8">  
</head>
  <body>
    <style>
      .hideP {
        visibility: hidden;
      }
    </style>
    <!-- Emulator -->
    <div>
      <img src="img/KIM-1.jpg" style="position: absolute; left: 0px; top: 0px;"/>
      <div id="serial_monitor" class="hideP" style="position: absolute; left: 62px; top: 150px; width: 650px; height: 345px; background-color: #000000; color: #00FF00; border: 2px solid #aaffaa; padding: 5px; overflow-y: scroll"></div>
      <input  id="serial_switch" type="checkbox" onchange="serial_mode ^= 1; document.getElementById('serial_monitor').classList.toggle('hideP'); reset(); document.activeElement.blur(); turnOffLED();" style="position: absolute; width: 22px; height: 22px; left: 700px; top: 124px; background-color: Transparent; cursor: pointer;"/>
      <div style="position: absolute; top: 130px; left: 585px; font-size: 16px; width: 120px; font-weight: bold; font-family: monospace; color: #ffffff;">Serial mode:</div>
      <input  id="SST" type="checkbox" onchange="single_step ^= 1" style="position: absolute; width: 22px; height: 22px; left: 650px; top: 665px; background-color: Transparent; cursor: pointer;"/>
      <button id="GO" onmousedown="keypad(0x13);" onmouseup="lightdown(); char_pending = 0x15;" ontouchstart="keypad(0x13);" ontouchend="lightdown(); char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 515px; top: 661px; background-color: Transparent; cursor: pointer;"></button>
      <button id="ST" onmousedown="stop();"       onmouseup="char_pending = 0x15;" ontouchstart="stop();"      ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 560px; top: 661px; background-color: Transparent; cursor: pointer;"></button>
      <button id="RS" onmousedown="reset();"      onmouseup="char_pending = 0x15;" ontouchstart="reset();"     ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 605px; top: 661px; background-color: Transparent; cursor: pointer;"></button>
      <button id="AD" onmousedown="keypad(0x10);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x10)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 515px; top: 706px; background-color: Transparent; cursor: pointer;"></button>
      <button id="DA" onmousedown="keypad(0x11);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x11)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 560px; top: 706px; background-color: Transparent; cursor: pointer;"></button>
      <button id="PC" onmousedown="keypad(0x14);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x14)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 605px; top: 706px; background-color: Transparent; cursor: pointer;"></button>
      <button id="+" onmousedown="keypad(0x12);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x12)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 650px; top: 706px; background-color: Transparent; cursor: pointer;"></button>
      <button id="C" onmousedown="keypad(0x0c);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x0c)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 515px; top: 751px; background-color: Transparent; cursor: pointer;"></button>
      <button id="D" onmousedown="keypad(0x0d);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x0d)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 560px; top: 751px; background-color: Transparent; cursor: pointer;"></button>
      <button id="E" onmousedown="keypad(0x0e);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x0e)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 605px; top: 751px; background-color: Transparent; cursor: pointer;"></button>
      <button id="F" onmousedown="keypad(0x0f);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x0f)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 650px; top: 751px; background-color: Transparent; cursor: pointer;"></button>
      <button id="8" onmousedown="keypad(0x08);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x08)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 515px; top: 796px; background-color: Transparent; cursor: pointer;"></button>
      <button id="9" onmousedown="keypad(0x09);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x09)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 560px; top: 796px; background-color: Transparent; cursor: pointer;"></button>
      <button id="A" onmousedown="keypad(0x0a);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x0a)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 605px; top: 796px; background-color: Transparent; cursor: pointer;"></button>
      <button id="B" onmousedown="keypad(0x0b);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x0b)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 650px; top: 796px; background-color: Transparent; cursor: pointer;"></button>
      <button id="4" onmousedown="keypad(0x04);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x04)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 515px; top: 841px; background-color: Transparent; cursor: pointer;"></button>
      <button id="5" onmousedown="keypad(0x05);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x05)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 560px; top: 841px; background-color: Transparent; cursor: pointer;"></button>
      <button id="6" onmousedown="keypad(0x06);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x06)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 605px; top: 841px; background-color: Transparent; cursor: pointer;"></button>
      <button id="7" onmousedown="keypad(0x07);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x07)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 650px; top: 841px; background-color: Transparent; cursor: pointer;"></button>
      <button id="0" onmousedown="keypad(0x00);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x00)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 515px; top: 886px; background-color: Transparent; cursor: pointer;"></button>
      <button id="1" onmousedown="keypad(0x01);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x01)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 560px; top: 886px; background-color: Transparent; cursor: pointer;"></button>
      <button id="2" onmousedown="keypad(0x02);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x02)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 605px; top: 886px; background-color: Transparent; cursor: pointer;"></button>
      <button id="3" onmousedown="keypad(0x03);" onmouseup="char_pending = 0x15;" ontouchstart="keypad(0x03)" ontouchend="char_pending = 0x15;" style="position: absolute; width: 32px; height: 32px; left: 650px; top: 886px; background-color: Transparent; cursor: pointer;"></button>
    </div>
    
    <!-- Assembler -->
    <div class="widget" style="position: absolute; left: 750px; top: 9px;">
      <div class="notes">
        <pre>
          <code>

==============================================
 Basic I/O
==============================================
  --------------------------------------------
               Print 6 digits
  --------------------------------------------
  0200 A9 00    START  LDA #0      zero into A
  0202 85 FB           STA POINTH  first 2
  0204 85 FA           STA POINTL  next 2
  0206 85 F9           STA INH     last 2
  0208 20 1F 1F  LOOP  JSR SCANDS  light up!
  020B 4C 08 02        JMP LOOP    do it again
  
  --------------------------------------------
                Echo keypad
  --------------------------------------------
  0200 D8       START CLD         clr dc mode
  0201 A9 00          LDA #0      zero into A
  0203 85 FB    STORE STA POINTH
  0205 85 FA          STA POINTL
  0207 85 F9          STA INH
  0209 20 1F 1F       JSR SCANDS  light up
  020C 20 6A 1F       JSR GETKEY  test keys
  020F 4C 03 02       JMP STORE

==============================================
 Useful ROM Routines
==============================================

  AK       $1EFE Check for key depressed. A non-zero: no key down. A equal 0, key down.
  SCAND    $1F19 Display address and contents.
  SCANDS   $1F1F Output six hex characters on display. Stored in $00F9, $00FA, $00FB.
  CONVD    $1F48 Output HEX digit
  OUTPUT   $1F4E Output 7 segment code stored in A register (to lit up a custom segment)
  KEYIN    $1F40 Open up keyboard channel. Call before using GETKEY (or call SCANDS).
  INCPT    $1F63 Increment display address.
  GETKEY   $1F6A Return key from keyboard. Value 0-F, 10(AD), 11(DA), 12(+), 13(GO), 14(PC), 15 (no keypress).
  TABLE    $1FE7 Table of 7-segment patterns.
  SAVE     $1C00 Normal interrupt entry point.
  RST      $1C22 Reset return to monitor.
  START    $1C4F Return to monitor entry

==============================================
 I/O addresses
==============================================

  $1740 SAD   7 segment output / keypad code
  $1741 PADD  6530 RIOT data direction
  $1742 SBD   display digit / keypad row

==============================================
 Machine Context (saved/restored by ST/GO):
==============================================

  00EF PC low
  00F0 PC high
  00F1 Status Register (NV-BDIZC)
  00F2 Stack Pointer
  00F3 A
  00F4 Y
  00F5 X

==============================================
 Status register layout:
==============================================

  N - Negative flag
  V - Overflow flag
  - - Expansion flag
  B - Break flag
  D - Decimal mode flag
  I - Interrupt flag
  Z - Zero flag
  C - Carry flag

==============================================
 NMI Initialization for Single Step and Stop:
==============================================
  (Pre-loaded into RAM)
  17FA 00
  17FB 1C

==============================================
 IRQ Initialization for BRK:
==============================================
  (Pre-loaded into RAM)
  17FE 00
  17FF 1C

==============================================
 USING A SERIAL TELEPRINTER
==============================================

The addition of a serial teleprinter (such as the Teletype Model
33ASR) to work with the KIM-1 system permits a variety of special opera-
tions to be performed.  In all cases, you define desired operations by
depressing the proper keys while simultaneously producing a hard-copy
printed record of each operation.  If your teleprinter is equipped
with a paper tape reader/punch, you may generate or read paper tapes
using the KIM-1 system.  Using the serial teleprinter, you may perform
the following operations:

  Select an Address

Type four hex keys (0 to F) to define the desired address.
Next, press the [SPACE] bar.
The printer will respond showing the address code selected
followed by a two digit hex code for data stored at the selected
address location:
   Type:                 1234        [SPACE]
   Printer Responds:     1234        AF
showing that the data AF is stored at location 1234.

  Modify Data

Select an address as in the previous section.  Now type two hex
characters to define the data to be stored at that address.  Next type
the [.] key to authorize the modification of data at the selected address:

   Type:                  1234  [SPACE]
   Printer Responds:      1234  AF
   Type:                              6D    [.]
   Printer Responds:      1235  B7

Note that the selected address (1234) has been modified and the system
increments automatically to the next address (1235).

   Note:  Leading zero's need not be entered for either address
          or data fields:  For example:
     
  EF [SPACE] selects address 00EF
   E [SPACE] selects address 000E
   A [.] enters data 0A
     [.] enters data 00 (etc.)

  Step to Next Address

Type [CR] to step to the next address without modifying the
current address:
    
  See Printed:            1234  AF
  Type:                             [CR]
  Printer Responds:       1235  B7
  Type:                             [CR]
  Printer Responds:       1236  C8          (etc.)

  Step to Preceeding Address

Type [LF] to step back to the preceeding address:

   See Printed:            1234  AF
   Type:                             [LF]
   Printer Responds:       1233  9D
   Type:                             [LF]
   Printer Responds:       1232  8E          (etc.)

  Punch Paper Tape

The KIM-1 system can be used to punch paper tapes having the
format described in Appendix F.  The procedures for generating these
tapes is as follows:

   1. Define the starting address and ending address of the
      data block to be punched on the paper tape.

   2. Load blank paper tape on the punch unit and activate
      the punch.

         Type:                       [1] [7] [F] [7] [SPACE]
         See Printed:    17F7    xx
         Type:                       [F] [F] [.]
         See Printed:    17F8    xx
         Type:                       [0] [3] [.]
         See Printed:    17F9    xx
         Type:                       [2] [0] [0]     [SPACE]
         See Printed:    0200    xx

You have now loaded the ending address (03FF) into address
locations 17F7 (EAL) and 17F8 (EAH).  The starting address (0200) is
selected as shown.

   3. Now type [Q]

         The paper tape will advance and punching of the data
         will proceed.  Simultaneously, a printed record of
         the data will be typed.

  List Program

A printed record of the contents of the KIM-1 memory may be
typed.  The procedure is the same as for punching paper tape except that
the punch mechanism is not activated.

  Execute Program

To initiate execution of a program using the TTY keyboard, the
following procedures should be followed:

   1. Enter the starting address of the program

   2. Type [G]
      For example, to begin program execution from
      address location 0200:
           Type:           [2] [0] [0] [SPACE]
           See Printed:    0200    xx
           Type:           [G]

  Program execution begins from location 0200 and will
  continue until the [ST] or [RS] keys of the KIM-1
  module are depressed.  The single step feature may
  be employed while in the TTY mode.

==============================================
 6502 Opcodes:
==============================================

ADC (ADd with Carry)
Affects Flags: N V Z C

MODE           SYNTAX       HEX LEN TIM
Immediate     ADC #$44      $69  2   2
Zero Page     ADC $44       $65  2   3
Zero Page,X   ADC $44,X     $75  2   4
Absolute      ADC $4400     $6D  3   4
Absolute,X    ADC $4400,X   $7D  3   4+
Absolute,Y    ADC $4400,Y   $79  3   4+
Indirect,X    ADC ($44,X)   $61  2   6
Indirect,Y    ADC ($44),Y   $71  2   5+

+ add 1 cycle if page boundary crossed

ADC results are dependant on the setting of the decimal flag.
In decimal mode, addition is carried out on the assumption that
the values involved are packed BCD (Binary Coded Decimal).
There is no way to add without carry.

---------------------------------------------- 

AND (bitwise AND with accumulator)
Affects Flags: N Z

MODE           SYNTAX       HEX LEN TIM
Immediate     AND #$44      $29  2   2
Zero Page     AND $44       $25  2   3
Zero Page,X   AND $44,X     $35  2   4
Absolute      AND $4400     $2D  3   4
Absolute,X    AND $4400,X   $3D  3   4+
Absolute,Y    AND $4400,Y   $39  3   4+
Indirect,X    AND ($44,X)   $21  2   6
Indirect,Y    AND ($44),Y   $31  2   5+

+ add 1 cycle if page boundary crossed

---------------------------------------------- 

ASL (Arithmetic Shift Left)
Affects Flags: N Z C

MODE           SYNTAX       HEX LEN TIM
Accumulator   ASL A         $0A  1   2
Zero Page     ASL $44       $06  2   5
Zero Page,X   ASL $44,X     $16  2   6
Absolute      ASL $4400     $0E  3   6
Absolute,X    ASL $4400,X   $1E  3   7

ASL shifts all bits left one position. 0 is shifted into bit 0
and the original bit 7 is shifted into the Carry.
 
----------------------------------------------

BIT (test BITs)
Affects Flags: N V Z

MODE           SYNTAX       HEX LEN TIM
Zero Page     BIT $44       $24  2   3
Absolute      BIT $4400     $2C  3   4

BIT sets the Z flag as though the value in the address tested
were ANDed with the accumulator. The N and V flags are set to
match bits 7 and 6 respectively in the value stored at the tested
address. BIT is often used to skip one or two following bytes as in:

CLOSE1 LDX #$10   If entered here, we
       .BYTE $2C  effectively perform
CLOSE2 LDX #$20   a BIT test on $20A2,
       .BYTE $2C  another one on $30A2,
CLOSE3 LDX #$30   and end up with the X
CLOSEX LDA #12    register still at $10
       STA ICCOM,X upon arrival here.

Beware: a BIT instruction used in this way as a NOP does have effects:
the flags may be modified, and the read of the absolute address,
if it happens to access an I/O device, may cause an unwanted action.

----------------------------------------------                 

Branch Instructions
Affect Flags: none

All branches are relative mode and have a length of two bytes.
Syntax is "Bxx Displacement" or (better) "Bxx Label".
See the notes on the Program Counter for more on displacements.

Branches are dependant on the status of the flag bits when the op code is encountered.
A branch not taken requires two machine cycles.
Add one if the branch is taken and add one more if the branch crosses a page boundary.

MNEMONIC                       HEX
BPL (Branch on PLus)           $10
BMI (Branch on MInus)          $30
BVC (Branch on oVerflow Clear) $50
BVS (Branch on oVerflow Set)   $70
BCC (Branch on Carry Clear)    $90
BCS (Branch on Carry Set)      $B0
BNE (Branch on Not Equal)      $D0
BEQ (Branch on EQual)          $F0

There is no BRA (BRanch Always) instruction but it can be easily emulated by branching
on the basis of a known condition. One of the best flags to use for this purpose is
the oVerflow which is unchanged by all but addition and subtraction operations.
A page boundary crossing occurs when the branch destination is on a different page
than the instruction AFTER the branch instruction. For example:

  SEC
  BCS LABEL
  NOP
A page boundary crossing occurs (i.e. the BCS takes 4 cycles) when (the address of) LABEL
and the NOP are on different pages. This means that

        CLV
        BVC LABEL
  LABEL NOP
the BVC instruction will take 3 cycles no matter what address it is located at.

----------------------------------------------

BRK (BReaK)
Affects Flags: B

MODE           SYNTAX       HEX LEN TIM
Implied       BRK           $00  1   7

BRK causes a non-maskable interrupt and increments the program counter by one.
Therefore an RTI will go to the address of the BRK +2 so that BRK may be used
to replace a two-byte instruction for debugging and the subsequent RTI will be correct.

----------------------------------------------

CMP (CoMPare accumulator)
Affects Flags: N Z C

MODE           SYNTAX       HEX LEN TIM
Immediate     CMP #$44      $C9  2   2
Zero Page     CMP $44       $C5  2   3
Zero Page,X   CMP $44,X     $D5  2   4
Absolute      CMP $4400     $CD  3   4
Absolute,X    CMP $4400,X   $DD  3   4+
Absolute,Y    CMP $4400,Y   $D9  3   4+
Indirect,X    CMP ($44,X)   $C1  2   6
Indirect,Y    CMP ($44),Y   $D1  2   5+

+ add 1 cycle if page boundary crossed

Compare sets flags as if a subtraction had been carried out.
If the value in the accumulator is equal or greater than the compared value,
the Carry will be set. The equal (Z) and negative (N) flags will be set based
on equality or lack thereof and the sign (i.e. A>=$80) of the accumulator.

---------------------------------------------- 

CPX (ComPare X register)
Affects Flags: N Z C

MODE           SYNTAX       HEX LEN TIM
Immediate     CPX #$44      $E0  2   2
Zero Page     CPX $44       $E4  2   3
Absolute      CPX $4400     $EC  3   4

Operation and flag results are identical to equivalent mode accumulator CMP ops.
 
----------------------------------------------

CPY (ComPare Y register)
Affects Flags: N Z C

MODE           SYNTAX       HEX LEN TIM
Immediate     CPY #$44      $C0  2   2
Zero Page     CPY $44       $C4  2   3
Absolute      CPY $4400     $CC  3   4

Operation and flag results are identical to equivalent mode accumulator CMP ops.

---------------------------------------------- 

DEC (DECrement memory)
Affects Flags: N Z

MODE           SYNTAX       HEX LEN TIM
Zero Page     DEC $44       $C6  2   5
Zero Page,X   DEC $44,X     $D6  2   6
Absolute      DEC $4400     $CE  3   6
Absolute,X    DEC $4400,X   $DE  3   7

---------------------------------------------- 

EOR (bitwise Exclusive OR)
Affects Flags: N Z

MODE           SYNTAX       HEX LEN TIM
Immediate     EOR #$44      $49  2   2
Zero Page     EOR $44       $45  2   3
Zero Page,X   EOR $44,X     $55  2   4
Absolute      EOR $4400     $4D  3   4
Absolute,X    EOR $4400,X   $5D  3   4+
Absolute,Y    EOR $4400,Y   $59  3   4+
Indirect,X    EOR ($44,X)   $41  2   6
Indirect,Y    EOR ($44),Y   $51  2   5+

+ add 1 cycle if page boundary crossed
             
----------------------------------------------

Flag (Processor Status) Instructions
Affect Flags: as noted

These instructions are implied mode, have a length of one byte and require two machine cycles.

MNEMONIC                       HEX
CLC (CLear Carry)              $18
SEC (SEt Carry)                $38
CLI (CLear Interrupt)          $58
SEI (SEt Interrupt)            $78
CLV (CLear oVerflow)           $B8
CLD (CLear Decimal)            $D8
SED (SEt Decimal)              $F8

Notes:
  The Interrupt flag is used to prevent (SEI) or enable (CLI) maskable interrupts (aka IRQ's).
  It does not signal the presence or absence of an interrupt condition.
  The 6502 will set this flag automatically in response to an interrupt and restore it to
  its prior status on completion of the interrupt service routine. If you want your interrupt
  service routine to permit other maskable interrupts, you must clear the I flag in your code.

  The Decimal flag controls how the 6502 adds and subtracts. If set, arithmetic is carried out
  in packed binary coded decimal. This flag is unchanged by interrupts and is unknown on power-up.
  The implication is that a CLD should be included in boot or interrupt coding.

  The Overflow flag is generally misunderstood and therefore under-utilised. After an ADC or SBC
  instruction, the overflow flag will be set if the twos complement result is less than -128
  or greater than +127, and it will cleared otherwise. In twos complement, $80 through $FF
  represents -128 through -1, and $00 through $7F represents 0 through +127. Thus, after:

  CLC
  LDA #$7F ;   +127
  ADC #$01 ; +   +1
the overflow flag is 1 (+127 + +1 = +128), and after:
  CLC
  LDA #$81 ;   -127
  ADC #$FF ; +   -1
  
the overflow flag is 0 (-127 + -1 = -128). The overflow flag is not affected by increments,
decrements, shifts and logical operations i.e. only ADC, BIT, CLV, PLP, RTI and SBC affect it.
There is no op code to set the overflow but a BIT test on an RTS instruction will do the trick.

----------------------------------------------

INC (INCrement memory)
Affects Flags: N Z

MODE           SYNTAX       HEX LEN TIM
Zero Page     INC $44       $E6  2   5
Zero Page,X   INC $44,X     $F6  2   6
Absolute      INC $4400     $EE  3   6
Absolute,X    INC $4400,X   $FE  3   7

---------------------------------------------- 

JMP (JuMP)
Affects Flags: none

MODE           SYNTAX       HEX LEN TIM
Absolute      JMP $5597     $4C  3   3
Indirect      JMP ($5597)   $6C  3   5

JMP transfers program execution to the following address (absolute) or to the location contained in
the following address (indirect). Note that there is no carry associated with the indirect jump so:

AN INDIRECT JUMP MUST NEVER USE A
VECTOR BEGINNING ON THE LAST BYTE
OF A PAGE

For example if address $3000 contains $40, $30FF contains $80, and $3100 contains $50,
the result of JMP ($30FF) will be a transfer of control to $4080 rather than $5080 as
you intended i.e. the 6502 took the low byte of the address from $30FF and the high byte from $3000.
 
----------------------------------------------

JSR (Jump to SubRoutine)
Affects Flags: none

MODE           SYNTAX       HEX LEN TIM
Absolute      JSR $5597     $20  3   6

JSR pushes the address-1 of the next operation on to the stack before transferring program
control to the following address. Subroutines are normally terminated by a RTS op code.

---------------------------------------------- 

LDA (LoaD Accumulator)
Affects Flags: N Z

MODE           SYNTAX       HEX LEN TIM
Immediate     LDA #$44      $A9  2   2
Zero Page     LDA $44       $A5  2   3
Zero Page,X   LDA $44,X     $B5  2   4
Absolute      LDA $4400     $AD  3   4
Absolute,X    LDA $4400,X   $BD  3   4+
Absolute,Y    LDA $4400,Y   $B9  3   4+
Indirect,X    LDA ($44,X)   $A1  2   6
Indirect,Y    LDA ($44),Y   $B1  2   5+

+ add 1 cycle if page boundary crossed

---------------------------------------------- 

LDX (LoaD X register)
Affects Flags: N Z

MODE           SYNTAX       HEX LEN TIM
Immediate     LDX #$44      $A2  2   2
Zero Page     LDX $44       $A6  2   3
Zero Page,Y   LDX $44,Y     $B6  2   4
Absolute      LDX $4400     $AE  3   4
Absolute,Y    LDX $4400,Y   $BE  3   4+

+ add 1 cycle if page boundary crossed
 
----------------------------------------------

LDY (LoaD Y register)
Affects Flags: N Z

MODE           SYNTAX       HEX LEN TIM
Immediate     LDY #$44      $A0  2   2
Zero Page     LDY $44       $A4  2   3
Zero Page,X   LDY $44,X     $B4  2   4
Absolute      LDY $4400     $AC  3   4
Absolute,X    LDY $4400,X   $BC  3   4+

+ add 1 cycle if page boundary crossed
 
----------------------------------------------

LSR (Logical Shift Right)
Affects Flags: N Z C

MODE           SYNTAX       HEX LEN TIM
Accumulator   LSR A         $4A  1   2
Zero Page     LSR $44       $46  2   5
Zero Page,X   LSR $44,X     $56  2   6
Absolute      LSR $4400     $4E  3   6
Absolute,X    LSR $4400,X   $5E  3   7

LSR shifts all bits right one position. 0 is shifted into bit 7
and the original bit 0 is shifted into the Carry.
 
----------------------------------------------

Wrap-Around
Use caution with indexed zero page operations as they are subject to wrap-around.
For example, if the X register holds $FF and you execute LDA $80,X you will not access $017F as you might expect; instead you access $7F i.e. $80-1. This characteristic can be used to advantage but make sure your code is well commented.

It is possible, however, to access $017F when X = $FF by using the Absolute,X
addressing modeof LDA $80,X. That is, instead of:

  LDA $80,X    ; ZeroPage,X - the resulting object code is: B5 80
  which accesses $007F when X=$FF, use:
  LDA $0080,X  ; Absolute,X - the resulting object code is: BD 80 00
  which accesses $017F when X = $FF (a at cost of one additional byte and one additional cycle). All of the ZeroPage,X and ZeroPage,Y instructions except STX ZeroPage,Y and STY ZeroPage,X have a corresponding Absolute,X and Absolute,Y instruction. Unfortunately, a lot of 6502 assemblers don't have an easy way to force Absolute addressing, i.e. most will assemble a LDA $0080,X as B5 80. One way to overcome this is to insert the bytes using the .BYTE pseudo-op (on some 6502 assemblers this pseudo-op is called DB or DFB, consult the assembler documentation) as follows:
  .BYTE $BD,$80,$00  ; LDA $0080,X (absolute,X addressing mode)

The comment is optional, but highly recommended for clarity.
In cases where you are writing code that will be relocated you must consider wrap-around
when assigning dummy values for addresses that will be adjusted. Both zero and the semi-standard
$FFFF should be avoided for dummy labels. The use of zero or zero page values will result in
assembled code with zero page opcodes when you wanted absolute codes. With $FFFF, the problem
is in addresses+1 as you wrap around to page 0.

----------------------------------------------

Program Counter
When the 6502 is ready for the next instruction it increments the program counter before
fetching the instruction. Once it has the op code, it increments the program counter by
the length of the operand, if any. This must be accounted for when calculating branches
or when pushing bytes to create a false return address (i.e. jump table addresses are
made up of addresses-1 when it is intended to use an RTS rather than a JMP).

The program counter is loaded least signifigant byte first. Therefore the most signifigant
byte must be pushed first when creating a false return address.

When calculating branches a forward branch of 6 skips the following 6 bytes so, effectively
the program counter points to the address that is 8 bytes beyond the address of the branch opcode;
and a backward branch of $FA (256-6) goes to an address 4 bytes before the branch instruction. 

Execution Times
Op code execution times are measured in machine cycles; one machine cycle equals one clock cycle.
Many instructions require one extra cycle for execution if a page boundary is crossed;
these are indicated by a + following the time values shown.

---------------------------------------------- 

NOP (No OPeration)
Affects Flags: none

MODE           SYNTAX       HEX LEN TIM
Implied       NOP           $EA  1   2

NOP is used to reserve space for future modifications or effectively REM out existing code.
 
----------------------------------------------

ORA (bitwise OR with Accumulator)
Affects Flags: N Z

MODE           SYNTAX       HEX LEN TIM
Immediate     ORA #$44      $09  2   2
Zero Page     ORA $44       $05  2   3
Zero Page,X   ORA $44,X     $15  2   4
Absolute      ORA $4400     $0D  3   4
Absolute,X    ORA $4400,X   $1D  3   4+
Absolute,Y    ORA $4400,Y   $19  3   4+
Indirect,X    ORA ($44,X)   $01  2   6
Indirect,Y    ORA ($44),Y   $11  2   5+

+ add 1 cycle if page boundary crossed

----------------------------------------------              

Register Instructions
Affect Flags: N Z

These instructions are implied mode, have a length of one byte and require two machine cycles.

MNEMONIC                 HEX
TAX (Transfer A to X)    $AA
TXA (Transfer X to A)    $8A
DEX (DEcrement X)        $CA
INX (INcrement X)        $E8
TAY (Transfer A to Y)    $A8
TYA (Transfer Y to A)    $98
DEY (DEcrement Y)        $88
INY (INcrement Y)        $C8

----------------------------------------------

ROL (ROtate Left)
Affects Flags: N Z C

MODE           SYNTAX       HEX LEN TIM
Accumulator   ROL A         $2A  1   2
Zero Page     ROL $44       $26  2   5
Zero Page,X   ROL $44,X     $36  2   6
Absolute      ROL $4400     $2E  3   6
Absolute,X    ROL $4400,X   $3E  3   7

ROL shifts all bits left one position. The Carry is shifted into bit 0
and the original bit 7is shifted into the Carry.

----------------------------------------------

ROR (ROtate Right)
Affects Flags: N Z C

MODE           SYNTAX       HEX LEN TIM
Accumulator   ROR A         $6A  1   2
Zero Page     ROR $44       $66  2   5
Zero Page,X   ROR $44,X     $76  2   6
Absolute      ROR $4400     $6E  3   6
Absolute,X    ROR $4400,X   $7E  3   7

ROR shifts all bits right one position. The Carry is shifted into bit 7
and the originalbit 0 is shifted into the Carry.

---------------------------------------------- 

RTI (ReTurn from Interrupt)
Affects Flags: all

MODE           SYNTAX       HEX LEN TIM
Implied       RTI           $40  1   6

RTI retrieves the Processor Status Word (flags) and the Program Counter from the stack
in that order (interrupts push the PC first and then the PSW).
Note that unlike RTS, the return address on the stack is the actual address
rather than the address-1.

---------------------------------------------- 

RTS (ReTurn from Subroutine)
Affects Flags: none

MODE           SYNTAX       HEX LEN TIM
Implied       RTS           $60  1   6

RTS pulls the top two bytes off the stack (low byte first) and transfers program control
to that address+1. It is used, as expected, to exit a subroutine invoked via JSR which
pushed the address-1.
RTS is frequently used to implement a jump table where addresses-1 are pushed onto the
stack and accessed via RTS eg. to access the second of four routines:

 LDX #1
 JSR EXEC
 JMP SOMEWHERE

LOBYTE
 .BYTE <ROUTINE0-1,<ROUTINE1-1
 .BYTE <ROUTINE2-1,<ROUTINE3-1

HIBYTE
 .BYTE >ROUTINE0-1,>ROUTINE1-1
 .BYTE >ROUTINE2-1,>ROUTINE3-1

EXEC
 LDA HIBYTE,X
 PHA
 LDA LOBYTE,X
 PHA
 RTS

----------------------------------------------

SBC (SuBtract with Carry)
Affects Flags: N V Z C

MODE           SYNTAX       HEX LEN TIM
Immediate     SBC #$44      $E9  2   2
Zero Page     SBC $44       $E5  2   3
Zero Page,X   SBC $44,X     $F5  2   4
Absolute      SBC $4400     $ED  3   4
Absolute,X    SBC $4400,X   $FD  3   4+
Absolute,Y    SBC $4400,Y   $F9  3   4+
Indirect,X    SBC ($44,X)   $E1  2   6
Indirect,Y    SBC ($44),Y   $F1  2   5+

+ add 1 cycle if page boundary crossed

SBC results are dependant on the setting of the decimal flag. In decimal mode,
subtraction is carried out on the assumption that the values involved are
packed BCD (Binary Coded Decimal).
There is no way to subtract without the carry which works as an inverse borrow.
i.e, to subtract you set the carry before the operation. If the carry is cleared
by the operation, it indicates a borrow occurred.

---------------------------------------------- 

STA (STore Accumulator)
Affects Flags: none

MODE           SYNTAX       HEX LEN TIM
Zero Page     STA $44       $85  2   3
Zero Page,X   STA $44,X     $95  2   4
Absolute      STA $4400     $8D  3   4
Absolute,X    STA $4400,X   $9D  3   5
Absolute,Y    STA $4400,Y   $99  3   5
Indirect,X    STA ($44,X)   $81  2   6
Indirect,Y    STA ($44),Y   $91  2   6

----------------------------------------------             

Stack Instructions
These instructions are implied mode, have a length of one byte and require machine
cycles as indicated. The "PuLl" operations are known as "POP" on most other microprocessors.
With the 6502, the stack is always on page one ($100-$1FF) and works top down.

MNEMONIC                        HEX TIM
TXS (Transfer X to Stack ptr)   $9A  2
TSX (Transfer Stack ptr to X)   $BA  2
PHA (PusH Accumulator)          $48  3
PLA (PuLl Accumulator)          $68  4
PHP (PusH Processor status)     $08  3
PLP (PuLl Processor status)     $28  4

---------------------------------------------- 

STX (STore X register)
Affects Flags: none

MODE           SYNTAX       HEX LEN TIM
Zero Page     STX $44       $86  2   3
Zero Page,Y   STX $44,Y     $96  2   4
Absolute      STX $4400     $8E  3   4

----------------------------------------------

STY (STore Y register)
Affects Flags: none

MODE           SYNTAX       HEX LEN TIM
Zero Page     STY $44       $84  2   3
Zero Page,X   STY $44,X     $94  2   4
Absolute      STY $4400     $8C  3   4

----------------------------------------------

          </code>
        </pre>
      </div>
      <div class="messages"><pre><code></code></pre></div>
      <canvas class="screen" width="160" height="160" hidden></canvas>
      <div class="debugger" hidden>
        <input type="checkbox" class="debug" name="debug" />
        <label for="debug">Debugger</label>
        <div class="minidebugger"></div>
        <div class="buttons">
          <input type="button" value="Step" class="stepButton" />
          <input type="button" value="Jump to ..." class="gotoButton" />
        </div>
      </div>

      <div class="monitorControls">
        <label for="start" hidden>Start: $</label>
        <input type="text" hidden value="0" class="start" name="start" />
        <label for="length" hidden>Length: $</label>
        <input type="text" hidden value="ff" class="length" name="length"/>
        <input type="button" value="Assemble" class="assembleButton buttons" />
        <input type="button" value="Upload" class="runButton buttons" />
        <input type="button" hidden value="Reset" class="resetButton buttons" />
        <input type="button" value="Hexdump" class="hexdumpButton buttons" />
        <input type="button" value="Disassemble" class="disassembleButton buttons" />
        <input type="button" value="Converter" onclick="openConverter();" class="buttons"/>
        <select id="timeScale">
          <option value="1">Timer 1</option>
          <option value="2">Timer 2</option>
          <option value="3">Timer 3</option>
          <option value="4">Timer 4</option>
          <option value="5" selected>Timer 5</option>
          <option value="6">Timer 6</option>
          <option value="7">Timer 7</option>
          <option value="8">Timer 8</option>
          <option value="9">Timer 9</option>
          <option value="10">Timer 10</option>
          <option value="11">Timer 11</option>
          <option value="12">Timer 12</option>
          <option value="13">Timer 13</option>
          <option value="14">Timer 14</option>
          <option value="15">Timer 15</option>
          <option value="16">Timer 16</option>
          <option value="17">Timer 17</option>
          <option value="18">Timer 18</option>
          <option value="19">Timer 19</option>
          <option value="20">Timer 20</option>
        </select>
        <input id="toggleDisplayMode" type="checkbox" style="position: relative; top: 5px; margin: 0px; margin-left: 7px; padding: 0px; width: 19px; height: 19px;"/>
      </div>
      <textarea id="code" class="code" style="font-size: 20px;" spellcheck="false" wrap="off"></textarea>
      <div class="monitor" hidden><pre><code></code></pre></div>    
    <script src="js/7-segment-display/Segment.js"></script>
    <script src="js/7-segment-display/SegmentDisplay.js"></script>
    <script src="js/6502_CPU/6502.dev.js"></script>
    <script src="js/KIM-1/KIM-1.js"></script>
    <script src="js/ASM/jquery.min.js"></script>
    <script src="js/ASM/assembler.js"></script>
    <script src="js/Converter/converter.js"></script>
    
    <!-- Code mirror editor -->
    <script src="js/codemirror/lib/codemirror.js"></script>
    <link rel="stylesheet" href="js/codemirror/lib/codemirror.css">
    <script src="js/codemirror/mode/gas/gas.js"></script>
    <script src="js/codemirror/addon/display/placeholder.js"></script>
    
    <style>
      .CodeMirror {
        font-family: monospace;
        font-size: 14px;
        border: 1px solid grey;
      }
    </style>
    
    <script>
      // init code mirror
      var editor = CodeMirror.fromTextArea(document.getElementById('code'), {
        mode:  "gas",
        lineNumbers: true,
        matchBrackets: true,
        indentUnit: 2
      });
      
      editor.setSize('97%', 422);

      // display size
      DISPLAY_WIDTH = 235;
      DISPLAY_HEIGHT = 64;
      DISPLAY_TRANSFORM_WIDTH = 2.5;
      DISPLAY_TRANSFORM_HEIGHT = 2.66;
      SEGMENT_WIDTH = 5;
      SEGMENT_HEIGHT = 12;
      SEGMENT_THICK = 4;
      SEGMENT_OFFSET = 10.4;
      
      // init display
      function setup() {
        let cnv = createCanvas(DISPLAY_WIDTH, DISPLAY_HEIGHT);
        cnv.position(473, 516);
        frameRate(60);
        ssd1 = new SegmentDisplay("7"); ssd1.update();
        ssd2 = new SegmentDisplay("7"); ssd2.update();
        ssd3 = new SegmentDisplay("7"); ssd3.update();
        ssd4 = new SegmentDisplay("7"); ssd4.update();
        ssd5 = new SegmentDisplay("7"); ssd5.update();
        ssd6 = new SegmentDisplay("7"); ssd6.update();
      }
      
      // update display
      function draw() {
        background(25);
        ssd1.update();
        ssd2.update();
        ssd3.update();
        ssd4.update();
        ssd5.update();
        ssd6.update();
      }
      
      // hack to light down LEDs before running a program        
      function lightdown() {
        ssd1.displayDigit(0); ssd1.update();
        ssd2.displayDigit(0); ssd2.update();
        ssd3.displayDigit(0); ssd3.update();
        ssd4.displayDigit(0); ssd4.update();
        ssd5.displayDigit(0); ssd5.update();
        ssd6.displayDigit(0); ssd6.update();
      }
      
      function keypad(key) { char_pending = key; }
      function resetCPU() { cpu.reset(); cpu.log(); }
      function stepCPU() { cpu.step(); cpu.log(); }
    </script>
	</body>

</html>
